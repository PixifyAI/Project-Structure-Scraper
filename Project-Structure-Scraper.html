<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub & Local Project Scraper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --neon-cyan: #00FFFF;
            --neon-cyan-glow: #00FFFF;
            --neon-cyan-light: #AFFFFF;
            --neon-cyan-dark: #00AAAA;
            --neon-green: #39FF14;
            --neon-green-glow: #39FF14;
            --neon-pink: #FF00FF;
            --neon-pink-glow: #FF00FF;
            --neon-red: #FF1818;
            --neon-red-glow: #FF4D4D;
            
            --dark-bg-primary: #050510; /* Deepest background */
            --dark-bg-secondary: #0D0D20; /* Main content card background */
            --dark-bg-tertiary: #1A1A3A; /* Inputs, buttons, lighter elements */
            --dark-bg-hover: #202045;

            --text-primary: var(--neon-cyan);
            --text-secondary: var(--neon-cyan-light);
            --text-muted: var(--neon-cyan-dark);
        }

        body {
            background-color: var(--dark-bg-primary);
            color: var(--text-secondary);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* A slightly more modern font */
        }

        /* Custom scrollbars */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: var(--dark-bg-secondary);
            border-radius: 5px;
            border: 1px solid var(--neon-cyan-dark);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--neon-cyan);
            border-radius: 5px;
            box-shadow: 0 0 5px var(--neon-cyan-glow);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--neon-cyan-light);
            box-shadow: 0 0 8px var(--neon-cyan-glow);
        }


        .neon-text {
            color: var(--text-primary);
            text-shadow: 
                0 0 2px var(--text-primary),
                0 0 5px var(--text-primary),
                0 0 10px var(--neon-cyan-glow),
                0 0 15px var(--neon-cyan-glow);
        }
        .neon-text-strong {
            color: #fff; /* Bright core for stronger glow */
            text-shadow:
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 15px var(--neon-cyan-glow),
                0 0 20px var(--neon-cyan-glow),
                0 0 25px var(--neon-cyan-glow),
                0 0 30px var(--neon-cyan-glow);
        }
        .neon-border {
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 5px var(--neon-cyan-glow), 0 0 10px var(--neon-cyan-glow) inset;
        }
        .neon-border-hover:hover {
            border-color: var(--neon-cyan-light);
            box-shadow: 0 0 8px var(--neon-cyan-glow), 0 0 15px var(--neon-cyan-glow) inset;
        }

        /* Override Tailwind bg-white for main card */
        .main-card {
            background-color: var(--dark-bg-secondary) !important;
            border: 2px solid var(--neon-cyan);
            box-shadow: 0 0 15px var(--neon-cyan-glow), 0 0 20px var(--neon-cyan-glow) inset;
            border-radius: 0.75rem; /* Corresponds to rounded-xl */
        }

        /* Header */
        .header-gradient { /* Replaces .bg-gradient-to-r from-blue-600 to-indigo-700 */
            background: linear-gradient(to right, var(--neon-cyan-dark), var(--neon-pink)) !important;
             border-bottom: 2px solid var(--neon-pink);
             box-shadow: 0 2px 10px var(--neon-pink);
        }
        .header-gradient h1 {
            color: white !important;
            text-shadow: 0 0 5px #fff, 0 0 10px var(--neon-pink-glow), 0 0 20px var(--neon-pink-glow);
        }
        .header-gradient p {
            color: var(--neon-cyan-light) !important;
            opacity: 0.9;
        }
        .header-icon-bg { /* Replaces .bg-white/20 */
            background-color: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 5px var(--neon-cyan-glow);
        }
        .header-icon-bg i {
            color: var(--neon-cyan) !important;
            text-shadow: 0 0 5px var(--neon-cyan-glow);
        }
        
        /* Tabs */
        .tab-container-bg { /* Replaces .bg-gray-100 */
            background-color: var(--dark-bg-tertiary) !important;
            border: 1px solid var(--neon-cyan-dark);
            box-shadow: 0 0 5px var(--neon-cyan-dark) inset;
        }
        .tab-button {
            color: var(--neon-cyan-dark);
            transition: all 0.3s ease;
            border: 1px solid transparent;
            border-radius: 0.375rem; /* rounded-md */
        }
        .tab-button:hover {
            color: var(--neon-cyan);
            background-color: var(--dark-bg-hover);
            border-color: var(--neon-cyan);
            text-shadow: 0 0 3px var(--neon-cyan-glow);
        }
        .tab-button.active {
            background-color: var(--neon-cyan) !important;
            color: var(--dark-bg-secondary) !important;
            font-weight: bold;
            text-shadow: none; /* Or a subtle dark shadow */
            box-shadow: 0 0 8px var(--neon-cyan-glow), 0 0 5px var(--neon-cyan-glow) inset;
        }

        /* Input fields */
        input[type="text"] {
            background-color: var(--dark-bg-tertiary) !important;
            border: 1px solid var(--neon-cyan-dark) !important;
            color: var(--neon-cyan-light) !important;
            border-radius: 0.375rem 0 0 0.375rem !important; /* Keep rounded-l-lg */
        }
        input[type="text"]::placeholder {
            color: var(--neon-cyan-dark) !important;
            opacity: 0.7;
        }
        input[type="text"]:focus {
            border-color: var(--neon-cyan) !important;
            box-shadow: 0 0 8px var(--neon-cyan-glow) !important;
            outline: none;
        }

        /* Buttons */
        .btn-primary { /* For scrape buttons etc. */
            background-color: transparent !important;
            border: 1px solid var(--neon-cyan) !important;
            color: var(--neon-cyan) !important;
            transition: all 0.3s ease;
            text-shadow: 0 0 3px var(--neon-cyan-glow);
        }
        .btn-primary:hover {
            background-color: var(--neon-cyan) !important;
            color: var(--dark-bg-secondary) !important;
            box-shadow: 0 0 10px var(--neon-cyan-glow), 0 0 15px var(--neon-cyan-glow);
            text-shadow: none;
        }
        .btn-primary:disabled {
            border-color: var(--neon-cyan-dark) !important;
            color: var(--neon-cyan-dark) !important;
            background-color: transparent !important;
            cursor: not-allowed;
            text-shadow: none;
            box-shadow: none;
        }
        .btn-download { /* For download button */
            background-color: transparent !important;
            border: 1px solid var(--neon-green) !important;
            color: var(--neon-green) !important;
            transition: all 0.3s ease;
            text-shadow: 0 0 3px var(--neon-green-glow);
        }
        .btn-download:hover {
            background-color: var(--neon-green) !important;
            color: var(--dark-bg-secondary) !important;
            box-shadow: 0 0 10px var(--neon-green-glow), 0 0 15px var(--neon-green-glow);
            text-shadow: none;
        }

        /* File Input Label */
        .file-input-label { /* replaces .bg-gray-100 */
            background-color: var(--dark-bg-tertiary) !important;
            border: 1px dashed var(--neon-cyan-dark) !important;
            color: var(--neon-cyan-dark) !important;
            transition: all 0.3s ease;
        }
        .file-input-label:hover {
            background-color: var(--dark-bg-hover) !important;
            border-color: var(--neon-cyan) !important;
            color: var(--neon-cyan) !important;
            box-shadow: 0 0 5px var(--neon-cyan-glow);
        }
        #folder-structure { /* Preview area for local folder */
            background-color: var(--dark-bg-primary) !important;
            border: 1px dashed var(--neon-cyan-dark) !important;
            color: var(--neon-cyan-light) !important;
        }
        #folder-structure .text-blue-600 { color: var(--neon-cyan) !important; } /* Folder icon/name */
        #folder-structure .text-gray-700 { color: var(--neon-cyan-light) !important; } /* File icon/name */


        /* Options Section */
        .options-bg { /* Replaces .bg-gray-50 */
            background-color: var(--dark-bg-tertiary) !important;
            border: 1px solid var(--neon-cyan-dark);
            box-shadow: 0 0 5px var(--neon-cyan-dark) inset;
        }
        .options-bg h3 {
            color: var(--neon-cyan) !important;
            text-shadow: 0 0 3px var(--neon-cyan-glow);
        }
        .options-bg label span { /* Text next to checkbox */
            color: var(--neon-cyan-light) !important;
        }
        input[type="checkbox"] {
            accent-color: var(--neon-cyan) !important; /* Modern way to style checkbox color */
            background-color: var(--dark-bg-secondary);
            border: 1px solid var(--neon-cyan-dark);
        }
        input[type="checkbox"]:checked {
            box-shadow: 0 0 5px var(--neon-cyan-glow);
        }

        /* Progress Bar */
        .progress-track-bg { /* Replaces .bg-gray-200 */
            background-color: var(--dark-bg-tertiary) !important;
            border: 1px solid var(--neon-cyan-dark);
        }
        .progress-bar-fill { /* Replaces .bg-blue-600 */
            background-color: var(--neon-cyan) !important;
            box-shadow: 0 0 8px var(--neon-cyan-glow), 0 0 3px var(--neon-cyan-glow) inset;
        }
        #progress-container .text-sm { /* Progress text */
            color: var(--neon-cyan-light) !important;
        }
        
        /* Results Area */
        #results-container h3 {
            color: var(--neon-cyan) !important;
            text-shadow: 0 0 3px var(--neon-cyan-glow);
        }
        #file-structure { /* Replaces .bg-gray-800 .text-gray-100 */
            font-family: 'Consolas', 'Courier New', monospace; /* Better mono font */
            background-color: var(--dark-bg-primary) !important;
            color: var(--neon-cyan-light) !important;
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 8px var(--neon-cyan-glow) inset, 0 0 5px var(--neon-cyan-glow);
            max-height: 400px; /* Increased max height */
        }
        #results-container .text-sm.text-gray-600 p { /* File count/size text */
             color: var(--neon-cyan-dark) !important;
        }

        /* Error Message */
        #error-container { /* Replaces .bg-red-50 .border-red-500 */
            background-color: rgba(255, 24, 24, 0.1) !important; /* Neon Red with alpha */
            border: 1px solid var(--neon-red) !important;
            border-left-width: 4px !important;
            box-shadow: 0 0 5px var(--neon-red-glow), 0 0 8px var(--neon-red-glow) inset;
        }
        #error-container .fa-exclamation-circle { color: var(--neon-red) !important; text-shadow: 0 0 5px var(--neon-red-glow); }
        #error-container h3 { color: var(--neon-red) !important; text-shadow: 0 0 3px var(--neon-red-glow); }
        #error-container p { color: var(--neon-red-glow) !important; }

        /* Footer */
        .footer-bg { /* Replaces .bg-gray-50 */
            background-color: var(--dark-bg-secondary) !important;
            border-top: 1px solid var(--neon-cyan-dark) !important;
            box-shadow: 0 -2px 5px var(--neon-cyan-dark);
        }
        .footer-bg div {
            color: var(--neon-cyan-dark) !important;
        }
        .footer-bg i {
            color: var(--neon-cyan) !important;
            text-shadow: 0 0 2px var(--neon-cyan-glow);
        }

        /* Loading Spinner */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 255, 0.3); /* Lighter neon color for track */
            border-radius: 50%;
            border-top-color: var(--neon-cyan); /* Neon color for spinner head */
            animation: spin 1s ease-in-out infinite;
            filter: drop-shadow(0 0 3px var(--neon-cyan-glow));
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .progress-bar {
            transition: width 0.3s ease;
        }
        
        /* GitHub Corner - was already there, just adjusting colors */
        .github-corner:hover .octo-arm {
            animation: octocat-wave 560ms ease-in-out;
        }
        @keyframes octocat-wave {
            0%, 100% { transform: rotate(0); }
            20%, 60% { transform: rotate(-25deg); }
            40%, 80% { transform: rotate(10deg); }
        }
        
        /* Generic text color overrides */
        .text-gray-700, .text-gray-800 { color: var(--text-secondary) !important; }
        .text-gray-500, .text-gray-600 { color: var(--text-muted) !important; }

        /* Ensure labels for inputs are neon */
        label.block.text-sm.font-medium {
            color: var(--neon-cyan-light) !important;
            text-shadow: 0 0 2px var(--neon-cyan-glow);
        }

    </style>
</head>
<body class="min-h-screen"> <!-- Removed bg-gray-100 -->
    <!-- GitHub corner ribbon -->
    <a href="https://github.com/PixifyAI/Project-Structure-Scraper" class="github-corner fixed right-0 top-0 z-10" aria-label="View source on GitHub">
        <svg width="80" height="80" viewBox="0 0 250 250" style="fill:var(--neon-cyan); color:var(--dark-bg-primary); position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
        </svg>
    </a>

    <div class="container mx-auto px-4 py-12 max-w-4xl">
        <div class="main-card overflow-hidden"> <!-- bg-white rounded-xl shadow-lg -->
            <!-- Header -->
            <div class="header-gradient p-6 text-white"> <!-- bg-gradient-to-r from-blue-600 to-indigo-700 -->
                <div class="flex items-center justify-between">
                    <div>
                        <h1 class="text-3xl font-bold neon-text-strong">Project Structure Scraper</h1>
                        <p class="mt-2 opacity-90">Extract complete project structure and content into a single text file for AI prompts</p>
                    </div>
                    <div class="header-icon-bg p-3 rounded-full"> <!-- bg-white/20 -->
                        <i class="fas fa-code text-3xl"></i>
                    </div>
                </div>
            </div>
            
            <!-- Main content -->
            <div class="p-6">
                <!-- Tab navigation -->
                <div class="flex mb-6 tab-container-bg rounded-lg p-1"> <!-- bg-gray-100 -->
                    <button id="github-tab" class="tab-button flex-1 py-2 px-4 rounded-md font-medium active">
                        <i class="fab fa-github mr-2"></i> GitHub Repository
                    </button>
                    <button id="local-tab" class="tab-button flex-1 py-2 px-4 rounded-md font-medium">
                        <i class="fas fa-folder-open mr-2"></i> Local Folder
                    </button>
                </div>
                
                <!-- GitHub tab content -->
                <div id="github-content" class="tab-content">
                    <div class="mb-6">
                        <label for="github-url" class="block text-sm font-medium mb-2">GitHub Repository URL</label>
                        <div class="flex">
                            <input type="text" id="github-url" placeholder="https://github.com/username/repository" 
                                   class="flex-1 px-4 py-2 border rounded-l-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"> <!-- border-gray-300 -->
                            <button id="scrape-github-btn" class="btn-primary px-6 py-2 rounded-r-lg font-medium transition-colors"> <!-- bg-blue-600 hover:bg-blue-700 text-white -->
                                <span id="github-btn-text">Scrape</span>
                                <span id="github-btn-spinner" class="loading-spinner hidden"></span>
                            </button>
                        </div>
                        <p class="mt-2 text-sm">Enter the full URL of a public GitHub repository</p> <!-- text-gray-500 -->
                    </div>
                </div>
                
                <!-- Local tab content -->
                <div id="local-content" class="tab-content hidden">
                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-2">Select Project Folder</label>
                        <input type="file" id="folder-input" webkitdirectory directory multiple class="hidden">
                        <label for="folder-input" class="file-input-label">
                            <i class="fas fa-folder-open mr-2"></i>
                            <span id="folder-name">Choose folder...</span>
                        </label>
                        <div id="folder-structure" class="hidden"> <!-- Styling applied via CSS -->
                            <p class="text-sm">Folder structure will be displayed here</p> <!-- text-gray-500 -->
                        </div>
                    </div>
                    <button id="scrape-local-btn" class="btn-primary px-6 py-2 rounded-lg font-medium transition-colors w-full"> <!-- bg-blue-600 hover:bg-blue-700 text-white -->
                        <span id="local-btn-text">Scrape Selected Folder</span>
                        <span id="local-btn-spinner" class="loading-spinner hidden"></span>
                    </button>
                </div>
                
                <!-- Options -->
                <div class="options-bg p-4 rounded-lg mb-6"> <!-- bg-gray-50 -->
                    <h3 class="font-medium mb-3">Options</h3> <!-- text-gray-800 -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="inline-flex items-center">
                                <input type="checkbox" id="include-code" class="rounded" checked> <!-- text-blue-600 removed -->
                                <span class="ml-2">Include file contents</span> <!-- text-gray-700 -->
                            </label>
                        </div>
                        <div>
                            <label class="inline-flex items-center">
                                <input type="checkbox" id="include-commits" class="rounded">
                                <span class="ml-2">Include commit history (GitHub only)</span>
                            </label>
                        </div>
                        <div>
                            <label class="inline-flex items-center">
                                <input type="checkbox" id="include-issues" class="rounded">
                                <span class="ml-2">Include issues (GitHub only)</span>
                            </label>
                        </div>
                        <div>
                            <label class="inline-flex items-center">
                                <input type="checkbox" id="include-readme" class="rounded" checked>
                                <span class="ml-2">Include README</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Progress -->
                <div id="progress-container" class="hidden mb-6">
                    <div class="flex justify-between mb-1">
                        <span class="text-sm font-medium">Scraping progress</span> <!-- text-gray-700 -->
                        <span id="progress-percent" class="text-sm font-medium">0%</span> <!-- text-gray-700 -->
                    </div>
                    <div class="w-full progress-track-bg rounded-full h-2.5"> <!-- bg-gray-200 -->
                        <div id="progress-bar" class="progress-bar progress-bar-fill h-2.5 rounded-full" style="width: 0%"></div> <!-- bg-blue-600 -->
                    </div>
                    <p id="progress-status" class="mt-1 text-sm">Preparing to scrape...</p> <!-- text-gray-500 -->
                </div>
                
                <!-- Results -->
                <div id="results-container" class="hidden">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-medium">Project Structure</h3> <!-- text-gray-800 -->
                        <button id="download-btn" class="btn-download px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center"> <!-- bg-green-600 hover:bg-green-700 text-white -->
                            <i class="fas fa-download mr-2"></i> Download
                        </button>
                    </div>
                    <div id="file-structure" class="file-structure p-4 rounded-lg overflow-x-auto max-h-96 overflow-y-auto"></div> <!-- bg-gray-800 text-gray-100 -->
                    <div class="mt-4 text-sm"> <!-- text-gray-600 -->
                        <p><span id="file-count">0</span> files processed | <span id="repo-size">0</span> KB</p>
                    </div>
                </div>
                
                <!-- Error message -->
                <div id="error-container" class="hidden border-l-4 p-4 mb-6"> <!-- bg-red-50 border-red-500 -->
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <i class="fas fa-exclamation-circle"></i> <!-- text-red-500 -->
                        </div>
                        <div class="ml-3">
                            <h3 class="text-sm font-medium" id="error-title">Error</h3> <!-- text-red-800 -->
                            <p class="text-sm mt-1" id="error-message"></p> <!-- text-red-700 -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <div class="footer-bg px-6 py-4 border-t"> <!-- bg-gray-50 border-gray-200 -->
                <div class="flex flex-col md:flex-row justify-between items-center text-sm"> <!-- text-gray-600 -->
                    <div class="mb-2 md:mb-0">
                        <i class="fas fa-code mr-1"></i> Project Structure Scraper v1.1
                    </div>
                    <div>
                        <i class="fas fa-info-circle mr-1"></i> Works with public GitHub repos and local folders
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // JavaScript remains the same
        document.addEventListener('DOMContentLoaded', function() {
            // UI Elements
            const githubTab = document.getElementById('github-tab');
            const localTab = document.getElementById('local-tab');
            const githubContent = document.getElementById('github-content');
            const localContent = document.getElementById('local-content');
            
            const scrapeGithubBtn = document.getElementById('scrape-github-btn');
            const githubUrlInput = document.getElementById('github-url');
            const githubBtnText = document.getElementById('github-btn-text');
            const githubBtnSpinner = document.getElementById('github-btn-spinner');
            
            const folderInput = document.getElementById('folder-input');
            const folderNameSpan = document.getElementById('folder-name');
            const folderStructureDiv = document.getElementById('folder-structure'); // Preview div
            const scrapeLocalBtn = document.getElementById('scrape-local-btn');
            const localBtnText = document.getElementById('local-btn-text');
            const localBtnSpinner = document.getElementById('local-btn-spinner');
            
            const fileStructureDiv = document.getElementById('file-structure'); // Main result display
            const resultsContainer = document.getElementById('results-container');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressPercent = document.getElementById('progress-percent');
            const progressStatus = document.getElementById('progress-status');
            const errorContainer = document.getElementById('error-container');
            const errorMessage = document.getElementById('error-message');
            const errorTitle = document.getElementById('error-title');
            const downloadBtn = document.getElementById('download-btn');
            const fileCountSpan = document.getElementById('file-count');
            const repoSizeSpan = document.getElementById('repo-size');
            
            // State variables
            let scrapedContent = '';
            let totalFiles = 0;
            let processedFiles = 0;
            let repoSizeKB = 0; 
            let selectedFiles = [];
            
            const GITHUB_API = 'https://api.github.com';
            
            githubTab.addEventListener('click', function() {
                githubTab.classList.add('active');
                localTab.classList.remove('active');
                githubContent.classList.remove('hidden');
                localContent.classList.add('hidden');
            });
            
            localTab.addEventListener('click', function() {
                localTab.classList.add('active');
                githubTab.classList.remove('active');
                localContent.classList.remove('hidden');
                githubContent.classList.add('hidden');
            });
            
            function showError(title, message) {
                errorTitle.textContent = title;
                errorMessage.textContent = message;
                errorContainer.classList.remove('hidden');
                setTimeout(() => {
                    errorContainer.classList.add('hidden');
                }, 5000);
            }
            
            function updateProgress(current, total, status) {
                if (total === 0 && current === 0) { 
                    progressBar.style.width = `0%`;
                    progressPercent.textContent = `0%`;
                } else {
                    const percent = Math.round((current / total) * 100);
                    progressBar.style.width = `${percent}%`;
                    progressPercent.textContent = `${percent}%`;
                }
                progressStatus.textContent = status;
                
                if (current === total && total > 0) {
                    progressStatus.textContent = 'Scraping complete!';
                }
            }
            
            function formatFileSize(kiloBytes) {
                const bytes = kiloBytes * 1024;
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            function resetState() {
                scrapedContent = '';
                totalFiles = 0;
                processedFiles = 0;
                repoSizeKB = 0;
                fileStructureDiv.textContent = '';
                resultsContainer.classList.add('hidden');
                errorContainer.classList.add('hidden');
                updateProgress(0,0, 'Preparing to scrape...');
            }
            
            function showResults(structureOutput) {
                fileStructureDiv.textContent = structureOutput;
                resultsContainer.classList.remove('hidden');
                fileCountSpan.textContent = totalFiles; 
                repoSizeSpan.textContent = formatFileSize(repoSizeKB); 
                
                let tempScrapedContent = scrapedContent; 
                tempScrapedContent += `\n${'='.repeat(50)}\n`;
                tempScrapedContent += `Total files processed: ${totalFiles}\n`;
                tempScrapedContent += `Total size processed: ${formatFileSize(repoSizeKB)}\n`;
                tempScrapedContent += `Scraped on: ${new Date().toLocaleString()}\n`;
                scrapedContent = tempScrapedContent; 
            }
            
            function isValidGitHubUrl(url) {
                try {
                    const parsedUrl = new URL(url);
                    return parsedUrl.hostname === 'github.com' && 
                           parsedUrl.pathname.split('/').filter(part => part).length >= 2;
                } catch {
                    return false;
                }
            }
            
            function extractOwnerAndRepo(url) {
                const parsedUrl = new URL(url);
                const pathParts = parsedUrl.pathname.split('/').filter(part => part);
                return {
                    owner: pathParts[0],
                    repo: pathParts[1].replace('.git', '') 
                };
            }
            
            async function getFileContent(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Failed to fetch file content (status ${response.status})`);
                    return await response.text();
                } catch (error) {
                    console.error('Error fetching file content:', error);
                    return `[Error: Could not fetch file content - ${error.message}]`;
                }
            }
            
            async function getRepoStructure(owner, repo, path = '', depth = 0) {
                const response = await fetch(`${GITHUB_API}/repos/${owner}/${repo}/contents/${path}`);
                if (!response.ok) {
                     if (response.status === 404 && path==="") { 
                        showError('API Error', `Repository ${owner}/${repo} not found or is private. Please check the URL.`);
                     } else if (response.status === 403) { 
                        showError('API Error', `Access to ${owner}/${repo} forbidden. Rate limit may have been exceeded or it's a private repository.`);
                     } else {
                        showError('API Error', `Failed to fetch structure for ${path || 'root'}. Status: ${response.status}`);
                     }
                    throw new Error(`Failed to fetch repository structure for ${path}. Status: ${response.status}`);
                }
                
                const contents = await response.json();
                if (!Array.isArray(contents)) return ''; 
                
                let structure = '';
                
                for (const item of contents) {
                    const indent = '  '.repeat(depth);
                    
                    if (item.type === 'dir') {
                        const dirLine = `${indent}üìÅ ${item.name}/\n`;
                        structure += dirLine;
                        scrapedContent += dirLine;
                        structure += await getRepoStructure(owner, repo, item.path, depth + 1);
                    } else if (item.type === 'file') {
                        totalFiles++; 
                        const fileLine = `${indent}üìÑ ${item.name}\n`;
                        structure += fileLine;
                        scrapedContent += fileLine;
                        
                        if (document.getElementById('include-code').checked && item.size < 1000000) { 
                            const fileContent = await getFileContent(item.download_url);
                            scrapedContent += `\n${'  '.repeat(depth + 1)}--- CONTENT START ---\n`;
                            scrapedContent += fileContent;
                            scrapedContent += `\n${'  '.repeat(depth + 1)}--- CONTENT END ---\n\n`;
                            repoSizeKB += Math.ceil(item.size / 1024);
                        } else if (item.size >= 1000000 && document.getElementById('include-code').checked) {
                            scrapedContent += `${'  '.repeat(depth + 1)}[File content skipped due to size > 1MB]\n\n`;
                        }
                        
                        processedFiles++;
                        updateProgress(processedFiles, Math.max(processedFiles, totalFiles), `Processing ${item.name}...`);
                    }
                }
                return structure;
            }
            
            async function getReadme(owner, repo) {
                try {
                    const response = await fetch(`${GITHUB_API}/repos/${owner}/${repo}/readme`);
                    if (!response.ok) return; 
                    
                    const readmeData = await response.json();
                    const content = await getFileContent(readmeData.download_url);
                    
                    const readmeHeader = `üìñ README (${readmeData.name})\n${'='.repeat(50)}\n${content}\n\n${'='.repeat(50)}\n\n`;
                    scrapedContent = readmeHeader + scrapedContent; 
                    repoSizeKB += Math.ceil(readmeData.size / 1024);
                } catch (error) {
                    console.warn('Could not fetch or process README:', error);
                }
            }
            
            folderInput.addEventListener('change', function(e) {
                selectedFiles = Array.from(e.target.files);
                
                if (selectedFiles.length === 0) {
                    folderNameSpan.textContent = 'Choose folder...';
                    folderStructureDiv.innerHTML = '<p class="text-sm">Folder structure will be displayed here</p>';
                    folderStructureDiv.classList.add('hidden');
                    return;
                }
                
                const paths = selectedFiles.map(file => file.webkitRelativePath);
                const commonPrefix = getCommonPathPrefix(paths);
                
                folderNameSpan.textContent = commonPrefix || (selectedFiles.length > 0 ? selectedFiles[0].webkitRelativePath.split('/')[0] : 'Selected folder');
                
                const structurePreview = generateFolderStructurePreview(selectedFiles, commonPrefix);
                folderStructureDiv.innerHTML = structurePreview;
                folderStructureDiv.classList.remove('hidden');
            });
            
            function getCommonPathPrefix(paths) {
                if (!paths || paths.length === 0) return '';
            
                if (paths.length === 1) {
                    const parts = paths[0].split('/');
                    if (parts.length > 1) return parts.slice(0, -1).join('/');
                    return ''; 
                }
            
                const splitPaths = paths.map(path => path.split('/'));
                const minLength = Math.min(...splitPaths.map(path => path.length));
                let commonParts = [];
            
                for (let i = 0; i < minLength; i++) {
                    const part = splitPaths[0][i];
                    if (splitPaths.every(p => p[i] === part)) {
                        commonParts.push(part);
                    } else {
                        break;
                    }
                }
                return commonParts.join('/');
            }
            
            function generateFolderStructurePreview(files, commonPrefix) {
                const root = {}; 
                files.forEach(file => {
                    const pathParts = file.webkitRelativePath.split('/');
                    let currentLevel = root;
                    pathParts.forEach((part, index) => {
                        if (!currentLevel[part]) {
                            currentLevel[part] = (index === pathParts.length - 1) ? 
                                { _isFile: true } : 
                                { _isDirectory: true, _children: {} };
                        }
                        if (index < pathParts.length - 1) {
                            if(!currentLevel[part]._children) currentLevel[part]._children = {}; 
                            currentLevel = currentLevel[part]._children;
                        }
                    });
                });
                return renderStructurePreviewRecursive(root, 0);
            }

            function renderStructurePreviewRecursive(node, depth) {
                let html = '';
                const indent = '¬†¬†'.repeat(depth); // Non-breaking space for indent
                
                Object.keys(node).sort((a, b) => {
                    const itemA = node[a];
                    const itemB = node[b];
                    if (itemA._isDirectory && !itemB._isDirectory) return -1; // Directories first
                    if (!itemA._isDirectory && itemB._isDirectory) return 1;
                    return a.localeCompare(b); // Then sort alphabetically
                }).forEach(name => {
                    const item = node[name];
                    if (item._isDirectory) {
                        html += `<div class="text-blue-600">${indent}üìÅ ${name}/</div>`; // class for styling
                        if (item._children) {
                            html += renderStructurePreviewRecursive(item._children, depth + 1);
                        }
                    } else if (item._isFile) {
                        html += `<div class="text-gray-700">${indent}üìÑ ${name}</div>`; // class for styling
                    }
                });
                return html;
            }
            
            async function processLocalFiles(filesToProcess, commonPrefix) {
                const rootTree = {};
                totalFiles = 0; 
                processedFiles = 0;
                repoSizeKB = 0;

                filesToProcess.forEach(file => {
                    let pathForTree = file.webkitRelativePath;
                    if (commonPrefix && pathForTree.startsWith(commonPrefix + '/')) {
                        pathForTree = pathForTree.substring(commonPrefix.length + 1);
                    } else if (commonPrefix === pathForTree) { 
                        pathForTree = file.name;
                    }
                    if (pathForTree === "") pathForTree = file.name; 

                    const parts = pathForTree.split('/').filter(p => p.length > 0);
                    let currentLevel = rootTree;
                    parts.forEach((part, index) => {
                        if (index === parts.length - 1) { 
                            currentLevel[part] = { _isFile: true, fileObject: file };
                        } else { 
                            if (!currentLevel[part] || currentLevel[part]._isFile) { 
                                currentLevel[part] = { _isDirectory: true, _children: {} };
                            } else if (!currentLevel[part]._children) { 
                                 currentLevel[part]._children = {};
                            }
                            currentLevel = currentLevel[part]._children;
                        }
                    });
                });

                let displayStructure = "";

                async function traverseAndScrape(node, depth) {
                    let currentLevelStructure = "";
                    const indent = '  '.repeat(depth);
                    const entries = Object.keys(node).sort((keyA, keyB) => {
                        const itemA = node[keyA];
                        const itemB = node[keyB];
                        const isDirA = itemA && itemA._isDirectory;
                        const isDirB = itemB && itemB._isDirectory;
                        if (isDirA && !isDirB) return -1;
                        if (!isDirA && isDirB) return 1;
                        return keyA.localeCompare(keyB);
                    });

                    for (const name of entries) {
                        const item = node[name];
                        if (item._isDirectory) {
                            const dirLine = `${indent}üìÅ ${name}/\n`;
                            currentLevelStructure += dirLine;
                            scrapedContent += dirLine;
                            if(item._children) {
                                currentLevelStructure += await traverseAndScrape(item._children, depth + 1);
                            }
                        } else if (item._isFile) {
                            totalFiles++; 
                            const fileLine = `${indent}üìÑ ${name}\n`;
                            currentLevelStructure += fileLine;
                            scrapedContent += fileLine;

                            const file = item.fileObject;
                            if (document.getElementById('include-code').checked && file.size < 1000000) { 
                                try {
                                    const content = await readFileAsText(file);
                                    scrapedContent += `\n${'  '.repeat(depth + 1)}--- CONTENT START ---\n`;
                                    scrapedContent += content;
                                    scrapedContent += `\n${'  '.repeat(depth + 1)}--- CONTENT END ---\n\n`;
                                    repoSizeKB += Math.ceil(file.size / 1024);
                                } catch (error) {
                                    scrapedContent += `\n${'  '.repeat(depth + 1)}[Error reading file content: ${error.message}]\n\n`;
                                }
                            } else if (item.fileObject.size >= 1000000 && document.getElementById('include-code').checked) {
                                scrapedContent += `${'  '.repeat(depth + 1)}[File content skipped due to size > 1MB]\n\n`;
                            }
                            processedFiles++;
                            updateProgress(processedFiles, filesToProcess.length, `Processing ${file.name}...`);
                        }
                    }
                    return currentLevelStructure;
                }
                
                displayStructure = await traverseAndScrape(rootTree, 0);

                if (document.getElementById('include-readme').checked) {
                    const readmeFile = filesToProcess.find(file => {
                        let pathForReadmeCheck = file.webkitRelativePath;
                         if (commonPrefix && pathForReadmeCheck.startsWith(commonPrefix + '/')) {
                            pathForReadmeCheck = pathForReadmeCheck.substring(commonPrefix.length + 1);
                        } else if (commonPrefix === pathForReadmeCheck) {
                            pathForReadmeCheck = file.name;
                        }
                        return (file.name.toLowerCase() === 'readme.md' || file.name.toLowerCase() === 'readme.txt' || file.name.toLowerCase() === 'readme') &&
                               !pathForReadmeCheck.includes('/'); 
                    });
                    
                    if (readmeFile) {
                        try {
                            const content = await readFileAsText(readmeFile);
                            const readmeHeader = `üìñ README (${readmeFile.name})\n${'='.repeat(50)}\n${content}\n\n${'='.repeat(50)}\n\n`;
                            scrapedContent = readmeHeader + scrapedContent; 
                            if (!document.getElementById('include-code').checked) {
                                repoSizeKB += Math.ceil(readmeFile.size / 1024);
                            }
                        } catch (error) {
                            scrapedContent = `[Notice: Found README (${readmeFile.name}) but couldn't read content: ${error.message}]\n\n` + scrapedContent;
                        }
                    } else {
                        scrapedContent = '[Notice: No README found at the root of the selected folder]\n\n' + scrapedContent;
                    }
                }
                updateProgress(processedFiles, filesToProcess.length, 'Processing complete.');
                return displayStructure;
            }
            
            function readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error || new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }
            
            scrapeGithubBtn.addEventListener('click', async function() {
                const githubUrl = githubUrlInput.value.trim();
                if (!isValidGitHubUrl(githubUrl)) {
                    showError('Invalid URL', 'Please enter a valid GitHub repository URL.');
                    return;
                }
                
                resetState();
                githubBtnText.classList.add('hidden');
                githubBtnSpinner.classList.remove('hidden');
                scrapeGithubBtn.disabled = true;
                progressContainer.classList.remove('hidden');
                updateProgress(0, 0, 'Starting GitHub scrape...');

                try {
                    const { owner, repo } = extractOwnerAndRepo(githubUrl);
                    scrapedContent = `Repository: ${owner}/${repo}\nURL: ${githubUrlInput.value.trim()}\n${'='.repeat(50)}\n\n`;
                    
                    if (document.getElementById('include-readme').checked) {
                        updateProgress(0, 1, 'Fetching README...'); 
                        await getReadme(owner, repo);
                    }
                    
                    updateProgress(0, 0, 'Fetching repository structure...'); 
                    const structure = await getRepoStructure(owner, repo);
                    
                    showResults(structure);
                    updateProgress(processedFiles, totalFiles, 'GitHub scraping complete!');

                } catch (error) {
                    if (!errorContainer.classList.contains('hidden')) { 
                         console.error('Scraping error already displayed:', error.message);
                    } else {
                         showError('Scraping Error', error.message || 'An unknown error occurred during GitHub scraping.');
                    }
                    updateProgress(processedFiles, totalFiles, 'Error during scraping.');
                } finally {
                    githubBtnText.classList.remove('hidden');
                    githubBtnSpinner.classList.add('hidden');
                    scrapeGithubBtn.disabled = false;
                }
            });
            
            scrapeLocalBtn.addEventListener('click', async function() {
                if (selectedFiles.length === 0) {
                    showError('No Folder Selected', 'Please select a folder to scrape.');
                    return;
                }
                
                resetState();
                localBtnText.classList.add('hidden');
                localBtnSpinner.classList.remove('hidden');
                scrapeLocalBtn.disabled = true;
                progressContainer.classList.remove('hidden');
                updateProgress(0, selectedFiles.length, 'Starting local folder scrape...');


                try {
                    const paths = selectedFiles.map(file => file.webkitRelativePath);
                    const commonPrefix = getCommonPathPrefix(paths);
                    
                    scrapedContent = `Local Folder: ${folderNameSpan.textContent || 'Selected Folder'}\n${'='.repeat(50)}\n\n`;
                    
                    const structureOutput = await processLocalFiles(selectedFiles, commonPrefix);
                    showResults(structureOutput);
                    
                } catch (error) {
                    console.error('Error scraping local folder:', error);
                    showError('Scraping Error', error.message || 'An unknown error occurred during local folder scraping.');
                     updateProgress(processedFiles, selectedFiles.length, 'Error during scraping.');
                } finally {
                    localBtnText.classList.remove('hidden');
                    localBtnSpinner.classList.add('hidden');
                    scrapeLocalBtn.disabled = false;
                }
            });
            
            downloadBtn.addEventListener('click', function() {
                if (!scrapedContent) {
                    showError('Nothing to download', 'Please scrape a project first.');
                    return;
                }
                const blob = new Blob([scrapedContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                let fileName = 'project-structure.txt';
                if (localContent.classList.contains('hidden')) { 
                    const githubUrl = githubUrlInput.value.trim();
                    if (githubUrl) {
                        try {
                            const { owner, repo } = extractOwnerAndRepo(githubUrl);
                            fileName = `${owner}-${repo}-structure.txt`;
                        } catch (e) { /* ignore, use default */ }
                    }
                } else { 
                    const baseName = folderNameSpan.textContent;
                    if (baseName && baseName !== 'Choose folder...' && baseName !== 'Selected folder') {
                        fileName = `${baseName.replace(/[\/\s]+/g, '_')}-structure.txt`;
                    }
                }
                
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            githubUrlInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault(); 
                    scrapeGithubBtn.click();
                }
            });
        });
    </script>
</body>
</html>
